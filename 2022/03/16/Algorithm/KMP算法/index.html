<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>KMP 算法 | Medamap's Blog</title><meta name="keywords" content="Medamap"><meta name="author" content="Medamap"><meta name="copyright" content="Medamap"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="KMP算法今天做到了 LeetCode 上的一道关于字符串的算法题 题目实现 strStr() 函数。 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。 说明： 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 n">
<meta property="og:type" content="article">
<meta property="og:title" content="KMP 算法">
<meta property="og:url" content="http://medamapuwu.github.io/2022/03/16/Algorithm/KMP%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Medamap&#39;s Blog">
<meta property="og:description" content="KMP算法今天做到了 LeetCode 上的一道关于字符串的算法题 题目实现 strStr() 函数。 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。 说明： 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 n">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/97713980_p0_master1200.jpg">
<meta property="article:published_time" content="2022-03-16T02:44:00.000Z">
<meta property="article:modified_time" content="2022-04-12T13:02:10.069Z">
<meta property="article:author" content="Medamap">
<meta property="article:tag" content="Medamap">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/97713980_p0_master1200.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://medamapuwu.github.io/2022/03/16/Algorithm/KMP%E7%AE%97%E6%B3%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":100},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'KMP 算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-12 21:02:10'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/02.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/97713980_p0_master1200.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Medamap's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">KMP 算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-16T02:44:00.000Z" title="发表于 2022-03-16 10:44:00">2022-03-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-12T13:02:10.069Z" title="更新于 2022-04-12 21:02:10">2022-04-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="KMP 算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>今天做到了 <code>LeetCode</code> 上的一道关于字符串的算法题</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现 <code>strStr()</code> 函数。</p>
<p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 <code>0</code> 开始）。如果不存在，则返回  <code>-1</code> 。</p>
<p>说明：</p>
<p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与 <code>C</code> 语言的 <code>strstr</code>() 以及 <code>Java</code> 的 <code>indexOf()</code> 定义相符。</p>
<p>示例 <code>1</code>：</p>
<p>输入：<code>haystack = &quot;hello&quot;, needle = &quot;ll&quot;</code><br>输出：<code>2</code></p>
<p>示例 <code>2</code>：</p>
<p>输入：<code>haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</code><br>输出：<code>-1</code></p>
<p>示例 <code>3</code>：</p>
<p>输入：<code>haystack = &quot;&quot;, needle = &quot;&quot;</code><br>输出：<code>0</code></p>
<h2 id="个人解读："><a href="#个人解读：" class="headerlink" title="个人解读："></a>个人解读：</h2><p>这道题就是一个字符串匹配的问题，<code>Java</code> 提供的的 <code>API </code>  <code>indexOf</code> 可以解决这个问题，但是没什么意义，最先想到的就是最笨的暴力破解，写出来后，测试直接超时 XD（有可能我的循环有问题）</p>
<p>需要注意的几个测试点（前两个本人踩过）：</p>
<ul>
<li><code>haystack</code> 为 <code>&quot;&quot;</code> 而 <code>needle</code> 不为 <code>&quot;&quot;</code></li>
<li>当 <code>haystack</code> 已经匹配到末尾，而 <code>needle</code> 还有未匹配的字符</li>
<li>示例 <code>2</code> 出现的没有匹配的字符</li>
<li><code>needle</code> 为 <code>&quot;&quot;</code></li>
</ul>
<h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><ul>
<li>最容易想到的方法：暴力比较，一个一个比较，容易超时</li>
<li>最简单的方法：直接调用官方给的 <code>API</code> 一行就可以解决 <code>return haystack.indexOf(needle);</code>（没啥用，来做 <code>LeetCode</code> 不是为了这个）</li>
<li>效率高的方法：就是我们今天介绍的主角 <strong><code>KMP</code> 算法</strong></li>
</ul>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p>推荐两个 <code>YouTube</code> 上的视频（从题解区拉来的，讲的很棒，就是需要科学上网 ）</p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=dgPabAsTFa8"><code>KMP</code> 过程介绍</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=3IFxpozBs2I"><code>KMP</code> 的代码</a></p>
<p>相较于下方的博客，这两个视频可以帮你更好的理解 KMP 的运作过程，以及核心 next 数组的求解过程（这里面叫 prefix）</p>
<p>但是个人认为，视频中讲述的 求解 next 数组中遇到不匹配字符情况时的处理 和 为何要寻找最长公共前后缀部分，对其原理解释的并不是很清楚，因此建议结合下面推荐的博客进一步理解原理问题</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dusf/p/kmp.html">KMP算法详解</a></p>
<p>相较于视频，这个博客用了大量的公式来证明了 指针移动的原理和合理性，系统的说明了匹配和不匹配的情况时的处理原理以及为什么这么要这么移动，可以让你明白这个 KMP 算法的原理，但是也正是因为有着大量的公式，并且夹杂着超长的解释（密密麻麻的全是字），所以一定要耐下心来看，对于公式部分建议结合具体的用例来看，代入数值的话会更加便于理解。（我是菜鸡） XD</p>
<p>这两个资料基本涵盖了我下面要说的内容，下面交代的内容是我将两者结合后结和我自己的思考总结出来的</p>
<p>下来说一下今天的主角</p>
<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a><code>KMP</code></h2><p>下面用 <code>T</code> 来代表 <code>haystack</code> ， 用 <code>P</code> 来代表 <code>needle</code></p>
<h3 id="暴力法的优缺点"><a href="#暴力法的优缺点" class="headerlink" title="暴力法的优缺点"></a>暴力法的优缺点</h3><p>讨论 <code>KMP</code> 算法之前，我们先说一下暴力法，流程如下：</p>
<ol>
<li>从头开始向右匹配</li>
</ol>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/image-20220315101439722.png" alt="image-20220315101439722" style="zoom:67%;" />

<ol start="2">
<li>遇到第一个匹配失败的字符</li>
</ol>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/image-20220315101648877.png" alt="image-20220315101648877" style="zoom:67%;" />

<ol start="3">
<li>匹配位置回到头部，向后移动一个位置</li>
</ol>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/image-20220315101939941.png" alt="image-20220315101939941" style="zoom:67%;" />

<p>以此类推，直至找到匹配项或到头为止。</p>
<p>暴力法的优点：</p>
<ul>
<li>代码简单，易于理解</li>
</ul>
<p>缺点：</p>
<ul>
<li>时间复杂度较大，效率低</li>
<li>每次比较失败后 <code>i</code> 指针与 <code>j</code> 指针都回溯，即使知道后面字符都不匹配，也会一一匹配再进行判断</li>
</ul>
<h3 id="KMP-算法的思想"><a href="#KMP-算法的思想" class="headerlink" title="KMP 算法的思想"></a><code>KMP</code> 算法的思想</h3><p>充分利用已经比较过的元素，让 <code>i</code> 指针保持不动，只移动 <code>j</code> 指针的位置，避免不必要的比较</p>
<h3 id="关于-KMP-的几个问题"><a href="#关于-KMP-的几个问题" class="headerlink" title="关于 KMP 的几个问题"></a>关于 <code>KMP</code> 的几个问题</h3><h4 id="KMP-算法的较为核心的操作是什么？"><a href="#KMP-算法的较为核心的操作是什么？" class="headerlink" title="KMP 算法的较为核心的操作是什么？"></a><code>KMP</code> 算法的较为核心的操作是什么？</h4><p>求出 <code>next</code> 数组（也就是前缀表 <code>(prefix table)</code> ， 不同人叫法不同，意义相同，我更加倾向于这么叫，可以自行代换），里面存放的是任一位置子串的<strong>最长公共前后缀</strong>的长度</p>
<h4 id="这个数组的作用是什么？"><a href="#这个数组的作用是什么？" class="headerlink" title="这个数组的作用是什么？"></a>这个数组的作用是什么？</h4><p>笼统的来讲：我们需要通过这个前缀表来确定 当比较到 <code>P</code> 中某个元素时，如果不匹配，我们可以通过 <code>next</code> 来跳到目前位置的子串中最长公共前后缀的位置，来避免无意义的比较。</p>
<p>用图来进一步解释一下：</p>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/image-20220315101648877.png" alt="image-20220315101648877" style="zoom:67%;" />

<p>我们下一步通过前缀表可以移动到如下位置</p>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/image-20220315102035507.png" alt="image-20220315102035507" style="zoom:67%;" />

<p>为什么可以移动到这里呢，它的原理是什么？</p>
<p>目测来说， <code>abcab</code> 中 除了头部和最后一个 <code>ab</code> ，没有其他匹配项了，</p>
<p>下面我们将从数学角度来解答这个疑惑</p>
<h4 id="为什么可以这样移动位置？"><a href="#为什么可以这样移动位置？" class="headerlink" title="为什么可以这样移动位置？"></a>为什么可以这样移动位置？</h4><p>书面文字不好理解，我们来看看实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 待匹配的字符串</span></span><br><span class="line">String haystack = <span class="string">&quot;abcabcabaa&quot;</span>;</span><br><span class="line"><span class="comment">// 需要找出的字符串</span></span><br><span class="line">String needle = <span class="string">&quot;abcabb&quot;</span>;</span><br><span class="line"><span class="comment">// next 数组</span></span><br><span class="line"><span class="keyword">int</span>[] next = &#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure>

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/image-20220316093713808.png" alt="image-20220316093713808" style="zoom:67%;" />

<p>我们首先将用 <code>3</code> 个变量 <code>i,j,k</code> 对 <code>haystack</code> 与 <code>needle</code> 进行区域的划分</p>
<ul>
<li><code>i</code> 是 <code>T</code> 的指针</li>
<li><code>j</code> 是 <code>P</code> 的指针</li>
<li><code>k</code> 是 匹配失败后 <code>j</code> 需要移动到的位置 ，即 <code>next[j] = k</code>（如何确定，下面会说）</li>
</ul>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/image-20220315102502761.png" alt="image-20220315102502761" style="zoom:67%;" />

<p>这时我们引入关于 <code>k</code> 的一个性质：<strong>最前面的 <code>k</code> 个字符与 <code>j</code> 前的最后 <code>k</code> 个字符是相同的</strong></p>
<p>数学表达式可以表示为 <code>( x ~ y : 是指范围从 x 到 y)</code>： **<code>P[0 ~ k-1] == P[j-k ~ j-1]</code>**（这里建议结合 <code>k</code> 的意义来理解）</p>
<ul>
<li>解释：带入上图内的数值可以得到 <code>P[0~1] = P[3~4]</code> 即 <code>P</code> 数组 <code>0</code> 到 <code>1</code> 之间的内容与 <code>3</code> 到 <code>4</code> 之间的内容相同</li>
</ul>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/image-20220315094516533.png" alt="image-20220315094516533" style="zoom:67%;" />

<p>当 <code>T[i] != P[j]</code> 即字符匹配失败时，可以得到 <code>T[i-j ~ i-1] == P[0 ~ j-1]  </code> </p>
<ul>
<li>解释：用下图举例，此时 <code>i = 8, j = 5, k = 2</code> <ul>
<li><code>i - j </code> 的位置指的是 <code>T</code> 与 <code>P</code> 在移动到当前位置后，第一个匹配成功的位置即 <code>i - j --&gt; 3</code><ul>
<li>那这个值有没有可能是不匹配的值呢？不可能，既然 <code>j</code> 移动到了非 <code>0</code> 的位置，说明前面的值一定是成功匹配的</li>
</ul>
</li>
<li><code>T[i-j ~ i-1]</code> 指的是从 第一个匹配成功的字符 到 最后一个匹配成功的字符 的所有字符的集合，即匹配成功的字段</li>
<li><code>P[0 ~ j-1]</code> 对应匹配成功的字段</li>
</ul>
</li>
</ul>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/image-20220315104226032.png" alt="image-20220315104226032" style="zoom:67%;" />

<p>而此时将性质 <code>P[0 ~ k-1] == P[j-k ~ j-1]</code> ，与 <code>T[i-j ~ i-1] == P[0 ~ j-1]</code> 条件相结合，就可以得出 ：</p>
<p><code>P[0 ~ k-1] == P[j-k ~ j-1] = T[i-k ~ i-1] = T[i-j ~ i-j+k-1] </code></p>
<ul>
<li>解释：下图解释<ul>
<li><code>T[i-j ~ i-1]</code> 与 <code>P[0 ~ j-1]</code> 的内容相同</li>
<li>在 <code>P[0 ~ j-1]</code> 中，存在  <code>P[0 ~ k-1] == P[j-k ~ j-1]</code> </li>
<li>相应的在 <code>T[i-j ~ i-1]</code>  一定存在 <code>T[i-k ~ i-1] = T[i-j ~ i-j+k-1]</code> （等价代换，<code>P</code> 与 <code>T</code> 内容相同，<code>P</code> 有的，<code>T</code> 一定会有）</li>
<li>那么这四段一定也相同 <code>P[0 ~ k-1] == P[j-k ~ j-1] = T[i-k ~ i-1] = T[i-j ~ i-j+k-1] </code></li>
</ul>
</li>
</ul>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/image-20220315105606770.png" alt="image-20220315105606770" style="zoom:67%;" />

<p>确定了之后，这里借用上方博客中的一句话来说明一下：</p>
<blockquote>
<p>该规律是KMP算法的关键，KMP算法是利用待匹配的子串自身的这种性质，来提高匹配速度。该性质在许多其他中版本的解释中还可以描述成：若子串的前缀集和后缀集中，重复的最长子串的长度为k，则下次匹配子串的j可以移动到第k位(下标为0为第0位)</p>
</blockquote>
<p>怎么理解这句话呢？你可以跟着我的思路来考虑一下这个问题</p>
<ol>
<li>我们要提高效率，就要保证移动是有意义的，也就是移动后避免不必要的比较</li>
<li>那么问题来了，什么是有必要的比较？相同的字符不需要比较，不同字符比较才是有必要的。</li>
<li>保证不同的字符范围太大，不可控，所以我们的目标就很明确了，保证<strong>移动后</strong>最大程度的避免比较相同的字符，那么如何做呢？</li>
<li>我们需要保证的是<strong>移动后的</strong> <code>j</code> 位置之前的子串尽可能的大（前面字符数越大说明我们剩下需要比较的次数越少，效率也就越高）</li>
<li>所以我们需要从<strong>移动前</strong> <code>j</code> 位置之前的子串中，找出最长的公共子串。最有效的办法就是从前后分别找相同的子串，因为这样可以保证移动的距离是最大的（从中间找不能保证移动的距离最大）</li>
<li>一旦找到了，就可以将尽可能多的的相同子串移动到最靠近错误匹配的位置</li>
</ol>
<p>因为<code>P[0 ~ k-1]</code> 与 <code>T[i-k ~ i-1]</code> 这两段的内容是相同的， 不需要浪费资源再次进行比较，所以我们直接将 <code>j</code> 移动到 <code>k</code> 的位置，也就等价于将 <code>P</code> 向后移动了</p>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/image-20220315110109380.png" alt="image-20220315110109380" style="zoom:67%;" />

<p>那么为什么可以移动的<strong>理论问题</strong>就解决了</p>
<h3 id="通过-next-移动具体流程"><a href="#通过-next-移动具体流程" class="headerlink" title="通过 next 移动具体流程"></a>通过 <code>next</code> 移动具体流程</h3><p>我们从 <code>0</code> 位置开始匹配字符：</p>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/image-20220315211122358.png" alt="image-20220315211122358" style="zoom:67%;" />

<p>当我们匹配到第 <code>6</code> 个字符时出现了错误，这时我们需要查看 <code>b</code> 字符，对应位置 <code>next</code> 数组内存放的数值，这个数值就 <code>j</code> 指针需要移动的位置 </p>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/image-20220315211221139.png" alt="image-20220315211221139" style="zoom:67%;" />

<p><code>next</code> 中值为 <code>2</code> ,所以 <code>j</code> 移动 <code>P</code> 数组中下标为 <code>2</code> 到的位置，再进行匹配</p>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/image-20220315153648660.png" alt="image-20220315153648660" style="zoom:67%;" />

<p>我们匹配到 <code>a</code> 字符时出现了错误</p>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/image-20220315211322383.png" alt="image-20220315211322383" style="zoom:67%;" />

<p>重复上面的操作 <code>j</code> 移动至下标为 <code>2</code> 的位置</p>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/image-20220315211508720.png" alt="image-20220315211508720" style="zoom:67%;" />

<p><code>j</code> 移动到下表为 <code>0</code> 的位置</p>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/image-20220315211619793.png" alt="image-20220315211619793" style="zoom:67%;" />

<p>接着向后移动至遇到不匹配的字符</p>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/image-20220315211715934.png" alt="image-20220315211715934" style="zoom:67%;" />

<p><code>j</code> 移动到下表为 <code>0</code> 的位置</p>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/image-20220315211817346.png" alt="image-20220315211817346" style="zoom:67%;" />

<p>再接着继续的话 <code>i</code> 就超过了 <code>T</code> 数组的长度，循环就结束了。</p>
<p>这里我们有种特殊的情况没有遇到，我举另外一个例子来说明一下这个特例（单纯为了说明这种情况，前面的移动就不要计较了哈XD）</p>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/image-20220315212054017.png" alt="image-20220315212054017" style="zoom:67%;" />

<p>这时，我们可以看到，第一个字符就不匹配，我们查看 <code>prefix_table</code> 里面的数值为 <code>-1</code> ，但是数组下标是从 <code>0</code> 开始的，这如何移动呢？</p>
<p>这里解释一下 <code>-1</code> 的作用：当我们第一个字符都不匹配时，我们就需要将 <code>i</code> 指针向后移动一位，而非 <code>j</code> 指针</p>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/image-20220315212157272.png" alt="image-20220315212157272" style="zoom:67%;" />

<p>这就是整个流程</p>
<h3 id="如何求-next-数组"><a href="#如何求-next-数组" class="headerlink" title="如何求 next 数组"></a>如何求 next 数组</h3><h5 id="求解最长公共前后缀长度-k："><a href="#求解最长公共前后缀长度-k：" class="headerlink" title="求解最长公共前后缀长度 k："></a>求解最长公共前后缀长度 <code>k</code>：</h5><ol>
<li>首先列出所有的可能的子串，以 <code>abcabb</code> 为例</li>
</ol>
<p>​        可能的子串集为：<code>&#123;a,ab,abc,abca,abcab&#125;</code> </p>
<ol start="2">
<li>然后求出 <code>P</code> 中所有位置的前后缀（前后缀的<strong>读取方向要一致</strong>，都为<strong>从左向右读取</strong>，前缀是从前面开始，后缀是从后面开始）</li>
</ol>
<blockquote>
<p>前缀集：除去最后一个字符的前面所有子串的集合</p>
<p>后缀集：除去第一个字符的后面所有子串的集合</p>
<p>（这里定义前后缀的语句是借鉴上方博客来的，自己总结不来XD）</p>
</blockquote>
<p>前缀集为：<code>&#123;a,ab,abc,abba,abcab&#125;</code>，后缀集为：<code>&#123;b,bb,abb,cabb,bcabb&#125;</code>，最长公共前后缀长度，也就是 <code>k</code> 为 <code>0</code></p>
<p>再举一个有公共长度的例子 <code>abcab</code></p>
<p>前缀集为：<code>&#123;a,ab,abc,abca&#125;</code>，后缀集为：<code>&#123;b,ab,cab,bcab&#125;</code>，最长公共前后缀长度，也就是 <code>k</code> 为 <code>2</code>  ，即<code>(ab)</code></p>
<p>分解为计算机的步骤我放在这里，取自上方博客</p>
<blockquote>
<p>1）找出前缀 <code>pre</code>，设为 <code>pre[0~m]</code>；</p>
<p>2）找出后缀 <code>post</code>，设为 <code>post[0~n]</code>；</p>
<p>3）从前缀 <code>pre</code> 里，先以最大长度的 <code>s[0~m]</code> 为子串，即设 <code>k</code> 初始值为 <code>m</code> ,跟 <code>post[n-m+1～n]</code> 进行比较：</p>
<p>如果相同，则 <code>pre[0~m]</code> 则为最大重复子串，长度为 <code>m</code>，则 <code>k=m</code> ;</p>
<p>如果不相同，则 <code>k=k-1</code> ;缩小前缀的子串一个字符，在跟后缀的子串按照尾巴对齐，进行比较，是否相同。</p>
<p>如此下去，直到找到重复子串，或者 <code>k</code> 没找到。</p>
</blockquote>
<h5 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h5><p>这里先来说明一下 <code>k</code> 值代表的含义（非常的巧妙）</p>
<ul>
<li><code> next[j] = k</code> ：代表着 <code>j</code> 位置比较失败后，需要移动到的下一个位置</li>
<li><code>k</code> 代表着 <code>j</code> 位置前面子串的最长公共前后缀的长度<ul>
<li>因为数组的下表从 <code>0</code> 开始的原因，<code>P[0~k-1] =  k</code> ，以 <code>abcabb</code> 这种情况举例，当比较到最后一个 <code>b</code> 字符时，匹配失败，此时 <code>k</code> 为 <code>2</code> ，是下一个要移动到的位置，<code>k</code> 前面的字符串的数量为这种情况的最长公共前后缀</li>
</ul>
</li>
</ul>
<p>分析求 <code>next</code> 的过程（请记住我们是在求 <code>next[j + 1]</code> 而不是别的，这个很重要！！！）</p>
<ol>
<li><code>j</code> 和 <code>k</code> 处的值相同</li>
</ol>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/image-20220315185542432.png" alt="image-20220315185542432" style="zoom:67%;" />

<p>由 <code>k</code> 的性质我们可得 <code>P[0 ~ k-1] == P[j-k ~ j-1]</code> ，此时 <code>P[j] = P[k]</code> 的，将两式子相加得</p>
<p> <code>P[0 ~ k-1] + P[k] == P[j-k ~ j-1] + P[j]</code>  这个式子结合上方的图可得 <code>P[0 ~ k] = P[j-k ~ j] = next[j + 1]</code></p>
<p>即 <code>next[j+1] = k + 1 = next[j] + 1</code></p>
<p>让我用通俗的语言来解释一下上面想要描述的解法：</p>
<ul>
<li><p>我们目前已经已经可以确定的是 <code>next[j] = k</code> （<code>j</code> 与 <code>k</code> 确定后，由性质可得），也就证明我们已经找到了到 <code>j</code> 这个字符<strong>前面的子串的最长公共前后缀的长度</strong> 以及 <strong>在 <code>j</code> 位置这个位置匹配失败时</strong> <code>j</code> 应该移动到的位置，都是是 <code>k</code> （原理前面解释了）</p>
</li>
<li><p>既然我们已经找到了 <code>next[j]</code> ,所以我们要寻找下一个位置的 最长长度以及移动的位置，这时，接下来的结果无非就两种情况</p>
<ul>
<li>下一个位置的字符可以添加到最长公共前后缀里面，现在的最长长度 <code>+ 1</code>，即 <code>k + 1</code>，并且 <code>j + 1</code> 位置匹配失败时应移动到的位置也是 <code>k + 1</code></li>
<li>匹配失败，具体操作我们下面单说</li>
</ul>
<p>这就是上面想要表述的问题，这么解释是为了后面我们用代码表示这个过程做铺垫。</p>
</li>
</ul>
<ol start="2">
<li><code>j</code> 和 <code>k</code> 处的值不相同</li>
</ol>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/image-20220315192058211.png" alt="image-20220315192058211" style="zoom:67%;" />

<p>当 <code>P[j] = P[k]</code> 时，<code>next[j + 1] = k + 1</code> ，最长长度变为了 <code>k + 1</code>。但是，此时 <code>P[j] != P[k]</code>，这说明了 我们已经不能用 <code>k + 1</code> 来解决这个问题了，我们要重新按照流程求，首先明确我们要找的是 <strong><code>P[0 ~ j]</code></strong> 的最长公共前后缀（因为我们要求的是 <code>next[j + 1]</code> ，即 <code>j + 1</code> 位置之前的子串， 而不是 <code>next[j]</code>）</p>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/image-20220315202807073.png" alt="image-20220315202807073" style="zoom:67%;" />

<p><strong>按这个例子来说</strong>，我们可以确定是 <code>next[j+1] &lt; 4</code> ，<strong>因为 <code>k = 4</code> 的情况是当 <code>P[j] = P[k]</code> 时才会出现，所以 <code>k</code> 的最大值也就是 <code>3</code></strong> ，又因为我们要找的是前后缀，要从最前和最后开始找，后面寻找的位置已经确定是 <code>P[j-k+1 ~ j]</code> 所以我们比较的最大范围就变为了从 <code>P[0 ~ k-1]</code> 之间寻找最大公共前后缀</p>
<p>你也可以这么理解：原来求解 <code>k</code> 是根据条件（字符是否匹配）来找答案（ <code>k</code> 的值），现在是给你答案的范围（ <code>k &lt; 4</code> ），让你去寻找条件（在哪个位置匹配才能满足 <code>k &lt; 4</code>  ）</p>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/image-20220316101651064.png" alt="image-20220316101651064" style="zoom:67%;" />

<p>而求 <code>P[0 ~ k-1]</code> 的最大公共前后缀不就是 <code>next[k]</code> 吗，所以，我们直接用 <code>k = next[k]</code> 即可处理不相等的情况，然后再次进行匹配，看看在  <code>next[k]</code> 位置的字符与 <code>P[j]</code> 位置的字符是否相等，如果不等，说明 <code>k &lt; next[k]</code> ,那么问题就转换为从 <code>P[0 ~ next[k] - 1]</code> 的范围内找匹配字符，直至 <code>k = -1</code>。</p>
<p>接着上方我的解释 ：这一步就是进一步缩小答案的范围 ，通过比较  <code>P[next[k]]</code> 与 <code>P[j]</code> 是否相同，将答案的范围从 <code>k &lt; 4</code> 缩小到 <code>k &lt; next[k]</code> 这个范围，我们根据这个范围，找满足答案的位置，这样我们就将范围从 <code>P[0 ~ k-1]</code> 缩小到 <code>P[0 ~ next[k]-1]</code>，按着这个逻辑，一直缩小到找到正确匹配的字符或者 <code>k == -1</code></p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><h4 id="求解-next-的程序"><a href="#求解-next-的程序" class="headerlink" title="求解 next[] 的程序"></a>求解 <code>next[]</code> 的程序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getNext(String P)&#123;</span><br><span class="line">    <span class="comment">// 首先将 String 转化为 char 数组</span></span><br><span class="line">    <span class="keyword">char</span>[] pattern = P.toCharArray();</span><br><span class="line">    <span class="comment">// 创建 next[] 数组</span></span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[P.length()];</span><br><span class="line">    <span class="comment">// 第一位为 -1</span></span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 创建两个指针</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 表示已经没有字符可以匹配成功了</span></span><br><span class="line">    <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 开始循环</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt; P.length() )&#123;</span><br><span class="line">        <span class="comment">// 如果 pattern[j] == pattern[k],说明 最大公共前后缀长度 +1,并且 j 向后移动一个单位</span></span><br><span class="line">        <span class="comment">// 或者 k == -1 ，说明没有可以匹配的字符，说明长度为 0</span></span><br><span class="line">        <span class="keyword">if</span>(k == -<span class="number">1</span> || pattern[j] == pattern[k])&#123;</span><br><span class="line">            <span class="comment">// j 指针后移</span></span><br><span class="line">            j++;</span><br><span class="line">            <span class="comment">// 最大长度 + 1</span></span><br><span class="line">            k++;</span><br><span class="line">            <span class="comment">// 赋值</span></span><br><span class="line">            next[j] = k;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 不相等，则从 next[k] 的位置找子串进行匹配，一直循环到没有可匹配的字符也就是 k = -1;</span></span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="next-数组求出来后，剩下的就按着逻辑写出-KMP-即可"><a href="#next-数组求出来后，剩下的就按着逻辑写出-KMP-即可" class="headerlink" title="next 数组求出来后，剩下的就按着逻辑写出 KMP 即可"></a><code>next</code> 数组求出来后，剩下的就按着逻辑写出 <code>KMP</code> 即可</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(String T, String P)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 先转换为字符数组</span></span><br><span class="line">    <span class="keyword">char</span>[] text = T.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] pattern = P.toCharArray();</span><br><span class="line">    <span class="comment">// 定义指针</span></span><br><span class="line">    <span class="comment">// 作用于 text 的 i 指针</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 作用于 pattern 的 j 指针</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 用于接收 next[] 的数组</span></span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[P.length()];</span><br><span class="line">    <span class="comment">// 计算 next[] 数组并返回</span></span><br><span class="line">    next = getNext(P);</span><br><span class="line">    <span class="comment">// 开始循环</span></span><br><span class="line">    <span class="comment">// 循环条件，i 和 j 都在范围内，其中一个超出说明就没找到或者已经找到</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; T.length() &amp;&amp; j &lt; P.length())&#123;</span><br><span class="line">        <span class="comment">// 开始匹配</span></span><br><span class="line">        <span class="comment">// j == -1 说明跳转到了 k = -1 的位置，说明第一个字符就不匹配，应该 i 移动，同时 j 归 0</span></span><br><span class="line">        <span class="comment">// 字符匹配，都向后移动</span></span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span> || text[i] == pattern[j])&#123;</span><br><span class="line">            j++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 将 j 移动到 next[j] 的位置</span></span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完全匹配成功，返回 i - j</span></span><br><span class="line">    <span class="keyword">if</span>(j == P.length())&#123;</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有匹配到</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="KMP-算法的进一步优化"><a href="#KMP-算法的进一步优化" class="headerlink" title="KMP 算法的进一步优化"></a><code>KMP</code> 算法的进一步优化</h4><p>这里借用一下博客中的例子来说明</p>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/image-20220316112641021.png" alt="image-20220316112641021" style="zoom:67%;" />

<p>我们看到此时 <code>T[i] != P[j]</code> ，我们现在需要做的就是与上面相同，将 <code>j</code> 移动至 <code>next[j]</code> 的位置这里呢也就是 <code>1</code> </p>
<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/image-20220316132840051.png" alt="image-20220316132840051" style="zoom:67%;" />

<p>我们可以看到，这时的比较与第一次的比较相同，因为两个不同的位置都是 <code>b</code> ，按照流程我们再次需要跳到 <code>next[next[j]]</code> 的位置，既然我们最终要移动到 <code>next[next[j]]</code> ，为何我们不在填充数组的时候就判断一下下一步移动的位置的字符是否与现在相同呢， 所以我们可以增加判断条件，避免这种没有意义的比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getNext(String P)&#123;</span><br><span class="line">    <span class="comment">// 首先将 String 转化为 char 数组</span></span><br><span class="line">    <span class="keyword">char</span>[] pattern = P.toCharArray();</span><br><span class="line">    <span class="comment">// 创建 next[] 数组</span></span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[P.length()];</span><br><span class="line">    <span class="comment">// 第一位为 -1</span></span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 创建两个指针</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 表示已经没有字符可以匹配成功了</span></span><br><span class="line">    <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 开始循环</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt; P.length())&#123;</span><br><span class="line">        <span class="comment">// 如果 pattern[j] == pattern[k],说明 最大公共前后缀长度 +1,并且 j 向后移动一个单位</span></span><br><span class="line">        <span class="comment">// 或者 k == -1 ，说明没有可以匹配的字符，说明长度为 0</span></span><br><span class="line">        <span class="keyword">if</span>(k == -<span class="number">1</span> || pattern[j] == pattern[k])&#123;</span><br><span class="line">            <span class="comment">// j 指针后移</span></span><br><span class="line">            j++;</span><br><span class="line">            <span class="comment">// 最大长度 + 1</span></span><br><span class="line">            k++;</span><br><span class="line">            <span class="comment">// 如果此时 pattern[j] 与 pattern[next[j](也就是 k )] 的字符相同，则直接将 next[k] 的值赋给 next[j]</span></span><br><span class="line">            <span class="keyword">if</span>(pattern[j] == pattern[k])&#123;</span><br><span class="line">                next[j] = next[k];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 赋值</span></span><br><span class="line">                next[j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 不相等，则从 next[k] 的位置找子串进行匹配，一直循环到没有可匹配的字符也就是 k = -1;</span></span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Medamap</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://medamapuwu.github.io/2022/03/16/Algorithm/KMP%E7%AE%97%E6%B3%95/">http://medamapuwu.github.io/2022/03/16/Algorithm/KMP%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://MedamapUwU.github.io" target="_blank">Medamap's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/97713980_p0_master1200.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/24/Collection/%E9%9B%86%E5%90%88/"><img class="prev-cover" src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/97713980_p0_master1200.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">集合学习</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/12/Collection/HashSet.add()%20%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%88%E7%9C%8B%E9%9F%A9%E8%80%81%E5%B8%88%E8%A7%86%E9%A2%91%EF%BC%89/"><img class="next-cover" src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/97713980_p0_master1200.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">HashSet底层源码</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/02.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Medamap</div><div class="author-info__description">Make EveryDay As Meaningful As Possible</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/MedamapUwU" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">KMP算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-number">1.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AA%E4%BA%BA%E8%A7%A3%E8%AF%BB%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">个人解读：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="toc-number">1.3.</span> <span class="toc-text">解决方案：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99"><span class="toc-number">1.4.</span> <span class="toc-text">相关资料</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP"><span class="toc-number">1.5.</span> <span class="toc-text">KMP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E6%B3%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.5.1.</span> <span class="toc-text">暴力法的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KMP-%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E6%83%B3"><span class="toc-number">1.5.2.</span> <span class="toc-text">KMP 算法的思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-KMP-%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.3.</span> <span class="toc-text">关于 KMP 的几个问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#KMP-%E7%AE%97%E6%B3%95%E7%9A%84%E8%BE%83%E4%B8%BA%E6%A0%B8%E5%BF%83%E7%9A%84%E6%93%8D%E4%BD%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">KMP 算法的较为核心的操作是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%99%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">这个数组的作用是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E7%A7%BB%E5%8A%A8%E4%BD%8D%E7%BD%AE%EF%BC%9F"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">为什么可以这样移动位置？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-next-%E7%A7%BB%E5%8A%A8%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-number">1.5.4.</span> <span class="toc-text">通过 next 移动具体流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%B1%82-next-%E6%95%B0%E7%BB%84"><span class="toc-number">1.5.5.</span> <span class="toc-text">如何求 next 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%82%E8%A7%A3%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E5%90%8E%E7%BC%80%E9%95%BF%E5%BA%A6-k%EF%BC%9A"><span class="toc-number">1.5.5.0.1.</span> <span class="toc-text">求解最长公共前后缀长度 k：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%82%E8%A7%A3"><span class="toc-number">1.5.5.0.2.</span> <span class="toc-text">求解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.6.</span> <span class="toc-text">程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E8%A7%A3-next-%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">求解 next[] 的程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#next-%E6%95%B0%E7%BB%84%E6%B1%82%E5%87%BA%E6%9D%A5%E5%90%8E%EF%BC%8C%E5%89%A9%E4%B8%8B%E7%9A%84%E5%B0%B1%E6%8C%89%E7%9D%80%E9%80%BB%E8%BE%91%E5%86%99%E5%87%BA-KMP-%E5%8D%B3%E5%8F%AF"><span class="toc-number">1.5.6.2.</span> <span class="toc-text">next 数组求出来后，剩下的就按着逻辑写出 KMP 即可</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KMP-%E7%AE%97%E6%B3%95%E7%9A%84%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.6.3.</span> <span class="toc-text">KMP 算法的进一步优化</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/14/DataBase/SQL%20%E4%BC%98%E5%8C%96/" title="SQL 优化"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/97713980_p0_master1200.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SQL 优化"/></a><div class="content"><a class="title" href="/2022/08/14/DataBase/SQL%20%E4%BC%98%E5%8C%96/" title="SQL 优化">SQL 优化</a><time datetime="2022-08-14T13:36:00.000Z" title="发表于 2022-08-14 21:36:00">2022-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/14/DataBase/SQL%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" title="SQL 性能分析"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/97713980_p0_master1200.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SQL 性能分析"/></a><div class="content"><a class="title" href="/2022/08/14/DataBase/SQL%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" title="SQL 性能分析">SQL 性能分析</a><time datetime="2022-08-14T13:36:00.000Z" title="发表于 2022-08-14 21:36:00">2022-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/13/DataBase/MySql%20%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" title="MySql 存储引擎"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/97713980_p0_master1200.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySql 存储引擎"/></a><div class="content"><a class="title" href="/2022/08/13/DataBase/MySql%20%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" title="MySql 存储引擎">MySql 存储引擎</a><time datetime="2022-08-13T12:39:00.000Z" title="发表于 2022-08-13 20:39:00">2022-08-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/13/DataBase/%E7%B4%A2%E5%BC%95/" title="MySql 索引及索引的用法"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/97713980_p0_master1200.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySql 索引及索引的用法"/></a><div class="content"><a class="title" href="/2022/08/13/DataBase/%E7%B4%A2%E5%BC%95/" title="MySql 索引及索引的用法">MySql 索引及索引的用法</a><time datetime="2022-08-13T12:39:00.000Z" title="发表于 2022-08-13 20:39:00">2022-08-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/13/SolveProblem/%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%20MySQL%20%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E6%83%85%E5%86%B5%EF%BC%88%E6%88%91%E5%AD%98%E6%94%BE%E7%9A%84%E6%98%AF%E9%BB%98%E8%AE%A4%E8%B7%AF%E5%BE%84%E5%8D%B3%20C%20%E7%9B%98%EF%BC%89/" title="如何查看 MySQL 中数据的存储情况"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/503/97713980_p0_master1200.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何查看 MySQL 中数据的存储情况"/></a><div class="content"><a class="title" href="/2022/08/13/SolveProblem/%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%20MySQL%20%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E6%83%85%E5%86%B5%EF%BC%88%E6%88%91%E5%AD%98%E6%94%BE%E7%9A%84%E6%98%AF%E9%BB%98%E8%AE%A4%E8%B7%AF%E5%BE%84%E5%8D%B3%20C%20%E7%9B%98%EF%BC%89/" title="如何查看 MySQL 中数据的存储情况">如何查看 MySQL 中数据的存储情况</a><time datetime="2022-08-13T12:39:00.000Z" title="发表于 2022-08-13 20:39:00">2022-08-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By Medamap</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>